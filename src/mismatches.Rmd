---
title: "Mismatches"
author: "Suman Sahil, Steve Simon"
date: "Creation date: 2019-10-16"
output: powerpoint_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r connect}
suppressMessages(suppressWarnings(library(sqldf)))
db <- dbConnect(SQLite(), dbname="../data/unmatched_labels_db.sqlite")
```

### How to handle mismatches

+ Quick overview of the four types of joins
+ Two specific cases
  + Labels in small table without matching codes in big table
  + Codes in big table without matching label in small table

<div class="notes">

In the previous module, I mentioned a simple case: every label in the small table has a code in the big table and vice versa. In this lecture, I'll discuss cases where you have mismatches. Before I do that, let me talk briefly about the four major types of joins.

</div>

### The inner join
+ SQL code
```
select * 
  from first_table as a
  inner join second_table as b
  on a.first_key=b.second_key
```
+ Remove mismatches in either direction
  + No null values created
+ Join order is not too important  

<div class="notes">

We'll describe this in more detail in a different video, but here's a quick overview of the four basic types of joins. 

The inner join removes any mismatches. If a key in the first table is not found in the second table, sorry but you're gone. If a key in the second table is not found in the first table, sorry but you're gone also.

Note that the order is not important here. If you swapped the first table and the second table, maybe the arrangement of the columns might change, and maybe the arrangement of the rows might change, but the table would be the same size and would effectively contain the same information.

</div>

### Simple inner join example

+ Original tables
```
first_key first_value 
B         Benjamin    
C         Charles

second_key second_value
A          Amsterdam
C          Casablanca
```
+ Results after inner join
```
first_key first_value second_key second_value
C         Charles      C          Casablanca
```

<div class="notes">

Here's a simple example of an inner join with mismatches going in both directions. The first table has Benjamin and Charles with keys of B and C. The second table has Amsterdam and Casablanca with keys of A and C.

Benjamin doesn't make it because B has no matching key in the second table. Amsterdam doesn't make it because A has no matching key in the first table. But you can match Charles with Casablanca because the C in the first table has a match in the second table. So the inner join has only one record.

</div>

### The left join
+ SQL code
```
select * 
  from first_table as a
  left join second_table as b
  on a.first_key=b.second_key
```
+ Removes mismatches from second database
+ Keeps mismatches from first database
  + Second database fields filled with null values
+ Join order is very important  

<div class="notes">

The left join will remove mismatches from the second database. If a key in the second database is not found in the first database, then sorry but you're gone.

Mismatches from the first database will not get tossed, however. If a key in the first database is not found in the second database, that's okay. Keep the record in the join. The fields that you couldn't find in the second database because of the mismatch? Let's set them to null.

Join order is very important for a left join.

</div>

### Simple left join example

+ Original tables
```
first_key first_value 
B         Benjamin    
C         Charles

second_key second_value
A          Amsterdam
C          Casablanca
```
+ Results after left join
```
first_key first_value second_key second_value
B         Benjamin    null       null
C         Charles     C          Casablanca
```

<div class="notes">

Here's the same simple example, but now with a left join. Benjamin in the first table has no match in the second table, but he's lucky because the left join will keep him in the final database, even without a match. The second key and second value fields are both set to null.

Amersterdam, however, is not so lucky. The left join will toss out any mismatches in the second table.

Charles and Casablanca get matched, of course, just like before.

</div>

### The right join
+ SQL code
```
select * 
  from first_table as a
  right join second_table as b
  on a.first_key=b.second_key
```
+ Removes mismatches from the first database
+ Keeps mismatches from the second database
    + First database fields filled with null values
+ Join order is very important
+ Important note: SQLite does not do right joins.
  + There is an easy work-around

<div class="notes">

The right join will remove mismatches from the first database. If a key in the first database is not found in the second database, then sorry but you're gone.

Mismatches from the second database will not get tossed, however. If a key in the second database is not found in the first database, that's okay. Keep the record in the database. The fields that you couldn't find in the first database because of the mismatch? Let's set them to null.

Join order is very important for a right join.

Note that SQLite cannot do a right join. It can only do an inner join and a left join. There is an easy work around for the right join. Just swap the order of the tables and do a left join.

</div>

### Equivalent joins
+ SQL code
```
select * 
  from first_table as a
  right join second_table as b
  on a.first_key=b.second_key
```
+ Swap order and change right to left
```
select * 
  from second_table as b
  left join first_table as a
  on b.second_key=a.first_key
```

<div class="notes">

It's not too hard to see how the second set of SQL commands will produce the same effective results as the first set of commands.

The order of the fields will be different, and the order of the records might or might not be different, but you get the same effective results.

Let me elaborate a bit on order. When you say "select *", you will get back all the fields in the table mentioned in the "from" statement followed by all the fields in the table mentioned in the "join" statement.

Order in SQL is often arbitrary, but what typically happens is that the join starts with the first record of the table mentioned in the "from" statement. That would be "Benjamin" if you coded things as "from table_one, but it would be "Amsterdam" if you coded things as "from table_two".

Of course, you can control the order in which fields appear by specifying that order in the "select" statement and you can control the order in which records appear by using an "order by" statement.

</div>

### Simple right join example

+ Original tables
```
first_key first_value 
B         Benjamin    
C         Charles

second_key second_value
A          Amsterdam
C          Casablanca
```
+ Results after right join
```
first_key first_value second_key second_value
null      null        A          Amsterdam
C         Charles     C          Casablanca
```

<div class="notes">

Here's that same set of tables with a right join. Benjamin gets the boot because he has no match in the second table. But Amsterdam makes the cut on a right join. Charles and Casablanca get matched, of course.

</div>

### Outer join, full join
+ Full join, outer join
  + Keeps mismatches from first database
    + Second database fields filled with null values
  + Keeps mismatches from the second database
    + First database fields filled with null values

<div class="notes">

A full join let's everyone join the party. A key in the first database that doesn't have a match in the second database? Come on it. We'll patch things up by using null values for the fields in the second database.

A key in the second database that doesn't have a match in the first database? Why, you're welcome too. We'll use null values for the fields in the first database.

</div>

### Simple outer join example

+ Original tables
```
first_key first_value 
B         Benjamin    
C         Charles

second_key second_value
A          Amsterdam
C          Casablanca
```
+ Results after outer join
```
first_key first_value second_key second_value
null      null        A          Amsterdam
B         Benjamin    null       null
C         Charles     C          Casablanca
```

<div class="notes">

Here's an example of an outer join. Benjamin gets in and Amsterdam gets in, in spite of their mismatches. Charles and Casablanca? They get in for any join--inner, left, right, or outer.

</div>

### unmatched_labels_db, listing of both tables

+ Listing of results_table
```{r}
dbGetQuery(conn=db, "select * from results_table")
```

+ Listing of sex_table
```{r}
dbGetQuery(conn=db, "select * from sex_table")
```

<div class="notes">

Let's look at an example with joining using labels. This is similar to the example you saw in an earlier video, but I've stripped it down so there are onle five records in the results table and we are only worried about labels for the sex variable.

There's a change here, though. There is a label "Did not answer" in the sex table, but the code of 9 associated with that label never appears in the results_table. This is not a surprise. There are many studies where everyone answers this question.

</div>

### unmatched_labels_db, exclude mismatch

```{r}
sql_code <- 
"select r.id, r.sex, s.sex_code, s.sex_label
  from results_table as r
  left join
  sex_table as s
  on r.sex=s.sex_code
  order by r.id"
dbGetQuery(conn=db, sql_code)
```

<div class="notes">

If you exclude the record in sex_table that does not have a match in the results_table, you get these results. You get five records total and you don't see a "9" or a "Did not answer" anywhere.

</div>

### unmatched_labels_db, include mismatch

```{r}
sql_code <- 
"select r.id, r.sex, s.sex_code, s.sex_label
  from sex_table as s
  left join
  results_table as r
  on r.sex=s.sex_code
  order by r.id"
dbGetQuery(conn=db, sql_code)
```

<div class="notes">

This is what the results look like if you allow the mismatched table to get in. There are six rows now, one more than the earlier result and you have a missing value for id.

There may be times when this is okay, but adding an extra phantom subject seems like a bad idea to me. Having a null value for the id variable seems like a bad idea to me. If a label is unmatched, you alomst always want to leave it out.

</div>

```{r switch-connections}
dbDisconnect(conn=db)
db <- dbConnect(SQLite(), dbname="../data/unmatched_codes_db.sqlite")
```

### unmatched_codes_db, listing of both tables

+ Listing of results_table
```{r}
dbGetQuery(conn=db, "select * from results_table")
```

+ Listing of sex_table
```{r}
dbGetQuery(conn=db, "select * from sex_table")
```

<div class="notes">

Here is a different case. In these two tables, there is a code in results_table that does not have a match in sex_table.

</div>

### unmatched_codes_db, exclude mismatch

```{r}
sql_code <- 
"select r.id, r.sex, s.sex_code, s.sex_label
  from sex_table as s
  left join
  results_table as r
  on r.sex=s.sex_code
  order by r.id"
dbGetQuery(conn=db, sql_code)
```

<div class="notes">

If you exclude the mismatch, one of the five subjects gets tossed out. From a data analysis perspective, this is almost always a bad idea.

</div>

### unmatched_codes_db, include mismatch

```{r}
sql_code <- 
"select r.id, r.sex, s.sex_code, s.sex_label
  from results_table as r
  left join
  sex_table as s
  on r.sex=s.sex_code
  order by r.id"
dbGetQuery(conn=db, sql_code)
```

<div class="notes">

Here are the results where you leave the mismatch in. It has the same number of subjects as the original results_table has. This seems like a better approach. You could replace the null value for label with the number code, or you could replace the null value with a string such as "Unlabeled."

</div>

### Practical recommendations (1/2)
+ Unmatched labels
  + Fairly common occurence
  + Usually best to exclude mismatches
+ Unmatched codes
  + Violation of database integrity
  + Usually best to include mismatches
    + Convert null label to number code
    + Convert null label to "Unlabeled"

<div class="notes">

Here's some practical advice that applies only to the setting where your extra tables include labels to match number codes in the main table.

Unmatched labels are a fairly common occurence. If you have 68,000 codes for diagnosis, it would be unrealistic to expect each of those codes to appear in the main table. You are usually best off ignoring the unmatched labels.

Unmatched codes, however, should almost never be ignored. There's a technical term associated with this, and I am not the one to talk about it, but the codes in the large table are foreign keys and a foreign key should always have a match in the table with the labels. A mismatch here is a violation of a fundamental rule of database integrity.

It is usually best to allow mismatches. Having a null value for the label is a small problem, but tossing out a legitimate record in the larger database is a bigger problem. Almost always, you want to include these types of mismatches.

</div>

### Practical recommendations (2/2)
+ Left join results_table to sex_table
  + Keeps size of results_table unchanged
  + Quickly convert null labels to something else
  
<div class="notes">

With these two rules in mind, ignoring unmatched labels but including unmatched codes, you should use a left join of results_table to the sex_table. This guarantees that no one in the results_table gets removed and also insures that you don't add extra "phantom" records with null id values.

It is usually good practice to quickly convert the null label back to the code number or to a generic term like "unlabeled."

</div>

```{r shut-down-gracefully}
dbDisconnect(conn=db)
```

